# BOJ 단어 정렬 문제 풀이 (C++ / 머지소트 직접 구현)

## 📌 문제 개요

- 단어 N개가 주어짐
- 길이 M 이상인 단어만 유효
- 정렬 조건:
  1. **등장 빈도 내림차순**
  2. **단어 길이 내림차순**
  3. **사전순 오름차순**

---

## 🧠 문제를 풀면서의 사고 흐름

### 1. 정렬 기준이 복합적이라 직접 정렬 구현이 필요하다고 판단
- sort + lambda로도 풀 수 있지만,
- **직접 머지소트를 구현해보며 연습하는 방향**을 선택

### 2. 등장 횟수 카운트를 위해 `unordered_map<string, int>` 사용
- 단어의 중복 여부를 빠르게 확인
- map에서 count가 1이면 처음 등장한 단어 → 배열에 저장

### 3. 단어 구조체 설계
```cpp
struct Data {
    string word;  // 단어
    int len;      // 길이
    int num;      // 등장 횟수
};
```
```
    구조체 기반으로 머지소트 구현

    merge() 내부에 3중 정렬 조건 직접 작성

4. 주요 실수

    초기에는 길이 조건 M 이상을 적용하지 않음 → "틀렸습니다" 발생

    정렬 범위도 mergeSort(0, idx);로 잘못 설정 → idx - 1이 맞음

    이 실수를 통해, **"조건문 하나 빠진 게 전체 로직을 무너뜨릴 수 있다"**는 교훈을 얻음

🚀 핵심 로직 요약

    unordered_map으로 빈도수 카운트

    Data 배열에 조건 만족하는 단어 저장

    머지소트로 정렬 조건 구현

    출력 시 \n 사용으로 속도 개선

📈 배운 점

    단순한 정렬 문제라도 조건이 여러 개면 직접 정렬 구현이 유효

    STL만 쓰는 게 능사는 아님 — 구조체 기반 사고 연습에 의미 있음

    사소한 조건 누락이 결과에 큰 영향을 미친다

    ++map[key] == 1 패턴은 중복 없이 삽입할 때 매우 유용함

🧪 예시 입력/출력
Input

7 4
apple
banana
apple
kiwi
banana
banana
pear

Output

banana
apple
pear

💬 마무리

이 문제는 "정렬 알고리즘 + 해시맵"의 조합을 연습하기에 좋은 문제였다.
무엇보다도, 직접 구현해보는 경험 자체가 가장 값진 수확이었다.


---
