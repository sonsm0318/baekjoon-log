# 🎲 랜덤 넘버 추측하기 - 사고 흐름 기반 문제 분석

> 백준 17225번 / 골드 1  
> 세그먼트 트리를 통한 가중치 인덱싱 문제

---

## 🧠 핵심 사고 흐름

- 문제 본질은 `가중치 기반 인덱싱`
  - 특정 위치를 기준으로, 어떤 "사람 번호"가 거기에 있는지를 찾는 구조
  - **순서를 유지하며** 매번 해당 값을 **삭제**해야 함

- 단순 배열로 구현 → 삭제 연산 시마다 `O(N)` → **비효율**
  - 매번 리스트에서 몇 번째 요소인지 찾고 지우는 건 **브루트포스** 접근
  - 난 그딴 거 안 함 ㅋㅋ

---

## 🧱 해결 전략

### 🔧 문제를 자료구조로 치환

- 문제를 보고 바로 떠오른 구조:
  - **세그먼트 트리 or 펜윅 트리 (BIT)**
    - `p[i]` → leaf 노드에 가중치
    - 내부 노드는 자식들의 가중치 누적
  - 인덱스 `x`에 대해 → "왼쪽부터 누적합이 x 이상이 되는 첫 사람"을 빠르게 찾는다

### ⚙️ 동작 순서

1. **초기화**
   - 배열 `arr[i] = p[i]`
   - 세그트리에 누적합 형태로 빌드

2. **xₖ번째 요소 찾기 (k번째 사람 찾기)**
   - `find_kth(k)` → 세그트리에서 왼쪽부터 내려가며 `k`번째 사람이 누구인지 찾음

3. **삭제 연산**
   - 찾은 사람의 가중치를 `0`으로 설정
   - 세그트리에 반영

---

## 🧩 중요한 구현적 판단

- `pull()` 위치 중요
  - 자식 갱신 후에만 부모를 갱신해야 함
  - 추상적으로 이해하고 있어야 lazy 도입 가능
- `query()` 내에서 `pull()` 무조건 호출은 ❌
  - 구조를 오염시킴

---

## 📚 내가 이 문제에서 얻은 것

- "순서 기반 가중치 인덱싱" 문제는 종종 세그트리로 변환 가능하다
- `remove + find_kth`는 **이진 탐색적 사고 + 세그 구조**를 합쳐야 해결 가능
- lazy를 고려한 추상화 구조 설계 연습이 실제 구현보다 더 중요할 수 있다

---

## 🛠️ 앞으로

- 이 문제는 그냥 시작일 뿐이고,
- 나중엔 **lazy propagation**, **persistent tree**, **order statistic tree**까지 확장할 수 있다
- 지금은 기반기를 쌓는 단계니까, 코드보다 사고 구조를 선명히 하는 데 집중
