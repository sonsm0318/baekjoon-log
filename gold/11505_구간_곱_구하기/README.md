# Segment Tree (곱 연산 기반) 구현 기록

## 🎯 목표

기본적인 세그트리 구조를 직접 구현하며, 구간 합이 아닌 **구간 곱 연산**으로 응용해보고자 함.  
또한 기존에 내가 시도했던 완전 이진 트리 기반 방식과 전통적인 재귀 구현 방식을 비교하고, 사고의 흐름을 정리함.

---

## 🧠 사고 과정 요약

### 1. **세그트리란?**

- 구간에 대한 합, 곱, 최소, 최대 등 다양한 연산을 빠르게 수행할 수 있는 트리 기반 자료구조
- 구간 쿼리와 업데이트를 O(log N)에 처리할 수 있다는 장점이 있음

---

### 2. **내가 처음 접근했던 방식**

- **완전 이진 트리 형태**로 세그트리를 구성
- 리프 노드를 `2N - 1` 배열 끝부터 거꾸로 채우고, 부모 노드는 자식 두 개의 곱으로 계산
- 각 노드에 `[start, end]` 범위를 직접 저장해서 구간 탐색을 수행함

➡️ **장점**: 직관적이고 시각적으로 구조를 이해하기 좋음  
➡️ **단점**: start/end 직접 관리 필요, 메모리 비효율, update/query 시 계산 복잡도 증가

---

### 3. **전통적인 재귀 구현으로 전환**

#### 전통 방식의 특징:
- `build(idx, start, end)`처럼 범위를 직접 인자로 넘겨서 구간을 분할
- `tree[idx]`를 기준으로 왼쪽/오른쪽 자식은 `2*idx`, `2*idx+1`
- `mid`를 기준으로 범위를 반씩 나누며 재귀 호출 → **구간 관리가 간결해짐**

➡️ 이 방식이 더 **간결하고 메모리 효율적**이라는 점을 깨달음  
➡️ 특히 `mid` 사용이 자연스럽고 직관적이라 전체 구현이 훨씬 깔끔해짐

---

### 4. **합 연산 → 곱 연산으로 변형**

#### 핵심 변경 사항:
- 합 연산(`+`) → 곱 연산(`*`)
- 항등원: 0 → **1** (query의 base case)
- **mod 연산 추가**: 곱은 값이 쉽게 커지므로 `1000000007`로 나눠줌

#### 주의점:
- `update()` 함수에서 실수: 비교 기준으로 `idx`를 사용했으나,
  **실제 갱신 인덱스는 `change`였기 때문에 `change < start || change > end`로 수정**

---

## ✅ 최종 코드 특징

- 재귀 기반 전통 세그트리 구조
- 구간 곱 연산에 최적화
- `MOD = 1,000,000,007`로 오버플로 방지
- 실수 포인트도 함께 경험하며 확실히 구조 이해에 도움됨

---

## 🔚 회고

- 완전 이진 구조로 직접 구현해본 경험은 구조적 사고에 큰 도움이 되었음
- 재귀 방식과의 차이점을 직접 체감하면서 왜 전통 방식이 널리 쓰이는지 확실히 이해할 수 있었음
- 연산자만 바꾸는 단순한 변형 같지만, 항등원과 모듈러 연산의 중요성도 같이 체감함
- 다음 단계는 **Lazy Propagation** 혹은 **최소/최대값 쿼리** 구현 도전 예정
