# 전위 순회로부터 후위 순회 출력하기

## 🧠 문제 해결 사고 흐름

### 1. 문제 구조 파악
- **전위 순회(preorder)**로 주어진 노드 순서를 보고 **후위 순회(postorder)**로 바꿔 출력해야 하는 문제.
- 전위 순회는 `[루트 -> 왼쪽 -> 오른쪽]` 순이고, 후위 순회는 `[왼쪽 -> 오른쪽 -> 루트]` 순.
- 노드의 개수가 명시되어 있지 않아, 입력은 `EOF`로 종료됨을 눈치채야 했다.

### 2. 트리 구조의 특징 이용
- 전위 순회에서 `preOrder[0]`은 무조건 루트임.
- 루트보다 **작은 값들은 왼쪽 서브트리**, **큰 값들은 오른쪽 서브트리**임을 이용하여 재귀적으로 나눌 수 있음.
- 이진 탐색 트리(BST)의 성질에 기반.

### 3. 재귀 구현 계획
- `solve(len, first)` 함수는 `preOrder[first]`를 루트로 하는 서브트리를 처리함.
- `len == 0`일 때는 **출력 없이 탈출해야 함** (재귀 종료 조건).
- 루트 다음부터 `루트보다 큰 수가 처음 나오는 위치`를 기준으로 왼쪽/오른쪽 서브트리 구분.

### 4. 핵심 구현 포인트
```cpp
int idx = first + 1;
while (idx < first + len && preOrderArray[idx] < root)
	idx++;
```

    idx는 오른쪽 서브트리의 시작 인덱스를 찾는 과정.

    왼쪽은 [first+1 ~ idx-1], 오른쪽은 [idx ~ first+len-1] 구간.

    후위 순회이므로 왼쪽 → 오른쪽 → 루트 순서로 출력해야 함.

5. 예외 처리에 대한 반성

    초기에 if (len > 1)만으로 처리했다가 len == 0인 경우 출력되어 버리는 문제가 생김.

    if (len <= 0) return;으로 고쳐야 정확한 베이스 케이스를 다룸.

💡 얻은 교훈

    입력 개수가 명시되지 않은 경우는 EOF 패턴을 먼저 의심하자.

    트리 문제는 "순서의 의미"만 정확히 이해하면 의외로 구현은 간결해진다.

    재귀 함수는 반드시 Base Case를 먼저 의심하고 설계하자.


---
