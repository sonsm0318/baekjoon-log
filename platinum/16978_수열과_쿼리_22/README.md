## 💥 실수 회고: 오프라인 쿼리 처리 중 `if` vs `while` 오류

### 🧠 문제 배경
- 쿼리 중 `2 k i j`는 **k번째 갱신까지 반영된 상태**에서의 부분합을 구해야 함.
- `1 i v` 갱신 쿼리들을 차례로 적용하면서, 쿼리의 시점(k)에 맞춰 세그먼트 트리를 갱신하는 구조로 접근함.
- 전체적으로는 올바른 사고였고, 설계도 잘 이루어짐.

---

### ❌ 실수 포인트
- `if (k > fIdx)` 조건으로 갱신 쿼리를 단 **1번만** 수행.
- 실제로는 `fIdx`가 `k`에 도달할 때까지 **여러 번 갱신을 반복적으로 적용**해야 하는 구조였음.
- 따라서 **`if` → `while`**로 변경해야 정답이 나옴.

---

### 🧩 핵심 원인 분석
- “**해당 시점까지 모든 갱신을 적용해야 한다**”는 요구를 **단발 조건**으로 착각함.
- **오프라인 쿼리에서 시점 누적 처리가 필요한 경우에는 반드시 누적 루프가 필요**하다는 점을 간과.

---

### ✅ 이후 사고 개선 방향
- 시점 기반 쿼리는 **'누적적 변화'**가 요구된다는 전제를 늘 먼저 점검.
- **상태를 만들고**, 그 상태에서 쿼리를 처리하는 순서를 명확히 분리해서 생각하기.
- `갱신 ≤ 현재 쿼리 시점`일 때까지 반복 → 기본 패턴으로 내재화하기.

---

### 🎯 교훈 요약
- 사소한 조건문 하나(`if` vs `while`)가 전체 로직의 정답을 좌우할 수 있다.
- **사고 구조는 맞더라도, 구현의 완전성은 별개의 문제**다.
- 구현 실수를 통해 사고 루틴의 견고함을 계속 보완해나가야 한다.
