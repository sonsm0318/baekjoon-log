# 증가 수열 개수 세기 (길이 11) - DP + 펜윅 트리

## 📌 난이도
플래티넘 IV

---

## 📄 문제 요약

- 길이 N의 수열 A가 주어질 때, **길이가 정확히 11인 증가 수열**의 개수를 구하라.
- A[i] ≤ 10^5, N ≤ 10^5

---

## ✅ 해결 전략

### 핵심 알고리즘: **DP + 펜윅 트리 (Binary Indexed Tree)**

1. `dp[k][x]` :=  
   길이가 `k`이고, 마지막 원소가 `x`일 때 가능한 증가 수열의 개수

2. 점화식:  
   `dp[k][A[i]] += ∑_{v=1}^{A[i]-1} dp[k-1][v]`  
   → A[i]보다 작은 수 중, 길이 `k-1`짜리 증가 수열들의 개수를 모두 더해서 A[i]에 붙인다.

3. 이 합을 빠르게 계산하기 위해서 → 펜윅 트리를 사용  
   → 길이별로 BIT를 11개 만들어 관리

---

## ⚙️ 구조

- 펜윅 트리 배열: `tree[12][100001]`  
  → `tree[k][x]`: 길이 `k`이고 값이 `x`인 증가 수열 개수의 누적합

- 각 수 A[i]에 대해:
  1. 길이 1짜리 수열은 자기 자신 → `update(1, A[i], 1)`
  2. 길이 2~11짜리는 이전 길이 수열의 누적합을 쿼리해서 확장
     - `val = query(k - 1, A[i] - 1)`
     - `update(k, A[i], val)`

---

## 🧠 핵심 함수 요약

- `query(k, x)` → `1 ~ x`까지의 누적합 (BIT)
- `update(k, x, val)` → `tree[k][x] += val` (BIT)

---

## ⏱ 시간복잡도

- 전체 시간: `O(11 × N log N)` = `O(N log N)` 수준
- 공간 복잡도: `O(11 × MAX_VAL)`

---

## ✅ 정리

- 전형적인 **DP + 누적합 최적화** 문제
- 값의 범위가 크고 정렬되지 않았기 때문에 **BIT 사용**
- 각 수마다 11개의 길이를 순회하며 가능한 증가 수열을 누적
- 최종 결과는 `query(11, MAX_VAL)`로 구함