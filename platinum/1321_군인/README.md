# ✅ 세그먼트 트리로 k번째 원소 찾기

## 📌 문제 요약

- `order == 1`: 특정 인덱스에 값을 추가 (`update`)
- `order == 2`: 누적 합 기준으로 k번째 원소의 인덱스 출력 (`query`)
- 구간 합 정보를 활용해 빠르게 탐색

---

## 💡 사용한 알고리즘

### 세그먼트 트리 (Segment Tree)

- 노드: 각 구간의 총합 저장
- 트리의 루트부터 시작해 좌/우로 분기하며 탐색
- `tree[idx << 1] >= find` → 왼쪽 서브트리로 이동  
  아니면 `find - 왼쪽` 값으로 오른쪽 이동

---

## 🧠 핵심 함수

### `build(int idx, int start, int end)`
- 배열 `arr`의 정보를 기반으로 트리 초기화

### `update(int idx, int start, int end, int find, int num)`
- `find` 위치에 `num`만큼 추가
- 이후 상위 노드에 값 반영

### `query(int idx, int start, int end, int find)`
- 현재 노드의 왼쪽 자식에서 `find`보다 크거나 같은 누적합이 있는지 검사
- 있으면 왼쪽 서브트리로, 없으면 오른쪽으로 재귀 호출

---

## 🧪 실수 및 복기

- `build()` 호출을 `main()`에서 빠뜨려 처음에 오답
- 익숙한 유형이라 **10분 내 해결**에 성공
- 실수 줄이기 위해 **초기화 루틴 확인 습관화 필요**

---

## 📝 한 줄 평

> 세그트리의 구조를 정확히 이해하고 있다면 `k번째 수 찾기`도 충분히 실전에서 빠르게 대응 가능하다.

