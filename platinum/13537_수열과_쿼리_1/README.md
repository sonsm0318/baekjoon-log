# 📘 [백준 13537번] 수열과 쿼리 1

> https://www.acmicpc.net/problem/13537  
> 자료구조 / 세그먼트 트리 (Merge Sort Tree)

---

## 🧩 문제 요약

- 크기가 N인 수열 A가 주어진다.
- 쿼리는 M개, 형식은 `i j k`
  - 구간 `[i, j]`에서 `k`보다 큰 원소의 개수를 출력

---

## 🧠 풀이 아이디어

### 🔍 핵심 관찰

- 단순히 매 쿼리마다 `A[i]~A[j]`를 순회하면 시간 초과 (`O(M·N)` = 최대 10⁹)
- → 구간 내에서 "k보다 큰 값"의 개수를 **빠르게 계산**해야 한다.
- 정렬된 구간을 기준으로 **이진 탐색** → upper_bound 사용
- 구간을 다루고 정렬도 유지해야 하므로 **Merge Sort Tree** 사용

### 🔧 자료구조 선택

- 각 세그먼트 트리 노드에 해당 구간의 정렬된 값들을 저장
- 쿼리 시, O(log N)개의 노드를 방문하며 각각 `upper_bound`로 k보다 큰 값 개수 계산

---

## 🧮 시간 복잡도

| 단계 | 복잡도 |
|------|--------|
| 초기 트리 구성 (`build`) | `O(N log N)` |
| 쿼리 1회 처리 | `O(log² N)` |
| 전체 쿼리 M개 | `O(M log² N)` |

- M, N ≤ 100,000 → 충분히 통과 가능

---

## ✅ 사용한 STL 함수

- `upper_bound`:
  - 정렬된 배열에서 특정 값보다 큰 **첫 번째 위치**를 이진 탐색으로 반환
  - `count = end() - upper_bound(..., k)` → `k보다 큰 값 개수`

---

## 💡 배운 점 & 느낀 점

- 세그먼트 트리 + 이진 탐색의 조합을 연습할 수 있는 대표 문제
- 쿼리 중 벡터를 병합하는 구현은 **시간 초과의 원인**이 된다
- **정렬된 상태**를 유지해야 할 때는 Merge Sort Tree를 고려할 수 있다
- `upper_bound`는 정확히 어떤 값을 기준으로 동작하는지 테스트하면서 감 잡는 것이 중요

---

## 🏁 관련 키워드

`세그먼트 트리` `구간 쿼리` `이진 탐색` `upper_bound` `정렬 유지` `Merge Sort Tree`
