# 📘 백준 1019번: 책 페이지

## ✅ 문제 요약

1부터 N까지의 모든 숫자를 나열했을 때,  
0부터 9까지 각각의 숫자가 **몇 번 등장하는지** 구하는 문제.

---

## 💡 문제의 핵심

- **브루트포스 접근 (1부터 N까지 모두 세기)** 는 시간 초과 발생
  - 최대 N이 10억이므로, O(N)으로는 불가능

- 해결 방법은 **자릿수별 규칙을 이용한 수학적 누적 계산**

---

## 🧠 아이디어 요약

1. N의 각 자릿수를 기준으로 분리:
   - `left`, `cur`, `right`  
   - 예: `543212345`에서 1의 자리 →  
     `left = 54321234`, `cur = 5`, `right = 0`

2. 자릿수마다 반복되는 패턴을 이용하여 등장 횟수를 계산:
   - `cur > d`: `(left + 1) * factor`
   - `cur == d`: `left * factor + (right + 1)`
   - `cur < d`: `left * factor`

3. **factor**는 1, 10, 100, ... 식으로 자릿수

---

## ⚠️ 예외 처리: 숫자 0

- **0은 앞자리에 올 수 없다**
  - 그런데 일반 규칙으로 계산하면 **맨 앞자리도 0이 있는 것처럼 처리된다**
  - 이를 보정하기 위해 0에 대해서는 `-factor`만큼 빼주는 보정 로직 필요

---

## ✅ 실수 포인트

- 숫자 0의 등장 횟수를 **중복 계산해서 잘못된 값이 나오는 경우**가 많음
- `if (i == 0)` 블럭에서 **조건 분기와 보정(-factor)**가 정확히 들어가야 함

---

## 📌 배운 점

- **자리수 분해 + 수학적 누적 사고**는 브루트포스보다 훨씬 강력하다
- 간단한 규칙이라도 **숫자 0처럼 예외적인 존재**는 특별히 처리해줘야 한다
- 구현보다 중요한 건, **전체 구조를 먼저 그릴 수 있는 능력**

---

## ✅ 느낀 점

처음엔 단순히 숫자를 나열해서 세려고 했지만,  
그 방식은 N이 클수록 금방 한계에 부딪힌다.  
각 자릿수마다 규칙을 찾아내고,  
그걸 수학적으로 일반화해서 누적 계산하는 방식은  
처음엔 어렵지만 문제를 푸는 관점을 넓혀준다.

특히 0 처리에서 "앞자리에 0이 올 수 없다"는 조건 하나가  
전체 로직을 뒤흔들 수 있다는 걸 체감했다.

