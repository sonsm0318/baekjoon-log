# 세그먼트 트리 + 등차수열 Lazy Propagation 구현 사고 점검표

## ✅ 1. 문제 추상화 제대로 했는가?
- [ ] 요구사항을 정확히 수식화했는가?
  - 예: "[L, R] 구간에 대해 A[L] += 1, A[L+1] += 2, ..., A[R] += R-L+1"
- [ ] 이는 결국 각 위치 i에 대해 "i - L + 1"을 더하는 것임을 인식했는가?
- [ ] 등차수열 덧셈이기 때문에 lazy propagation에서 `초항 + 공차`를 함께 관리해야 함을 이해했는가?

---

## ✅ 2. Lazy 값의 의미를 제대로 정했는가?
- [ ] lazyAdd: 해당 구간의 시작점에 더해질 **초항**을 의미하도록 설정했는가?
- [ ] lazySlope: 한 칸당 증가하는 **공차**를 나타내도록 설정했는가?
- [ ] 자식 노드로 전파할 때 lazyAdd는 위치 보정을 반드시 반영했는가?

---

## ✅ 3. 수식은 정확한가?
- [ ] 등차수열의 합 공식 `a * n + d * (n-1) * n / 2`를 정확히 기억했는가?
- [ ] len = (end - start + 1) 로 구간 길이를 계산했는가?
- [ ] sum 갱신 시 `lazyAdd * len + lazySlope * (len - 1) * len / 2` 를 사용했는가?

---

## ✅ 4. lazy 전파 시 오프셋 계산은 정확한가?
- [ ] 오른쪽 자식의 lazyAdd는 `부모 lazyAdd + lazySlope * (왼쪽 구간 길이)` 인가?
- [ ] 왼쪽 자식의 구간 길이 계산은 `mid - start + 1`로 했는가?
- [ ] len / 2 같은 단순한 정수 나눗셈을 쓰지 않았는가? (홀수 구간에서 깨짐)

---

## ✅ 5. lazyUpdate 호출 조건은 정확한가?
- [ ] `lazyAdd == 0 && lazySlope == 0`일 때만 return 하도록 했는가?
- [ ] lazyAdd만 0인 경우에도 lazySlope가 적용될 수 있음을 인식했는가?

---

## ✅ 6. update 후 sum을 반드시 재계산했는가?
- [ ] 자식에게 내려간 후 `tree[idx].sum = left.sum + right.sum`을 해줬는가?

---

## ✅ 7. 경계 조건 확인했는가?
- [ ] start == end일 때는 반드시 leaf 노드에서 처리했는가?
- [ ] 구간 외 범위는 `start > r || end < l`로 완전히 제외했는가?

---

## 🧠 추천 디버깅 루틴
- [ ] 쿼리 후 이상한 값이 나왔을 때 → lazy 전파가 누락된 노드는 없는가?
- [ ] update 시 초항이 음수가 되는 구간이 있는가? → `(start - l + 1)` 확인
- [ ] 오른쪽 자식의 시작값이 잘못된 경우 → 오프셋 보정 확인
- [ ] 자식 전파 후 sum을 갱신 안 한 경우 → `sum = L + R` 확인

---

## 🏁 총평
> 등차수열의 lazy propagation은 수학적으로는 간단하지만,  
> 실제 구현에서는 **수식 오류 하나, 오프셋 보정 하나만 틀려도 전체가 무너진다.**  
> 따라서 구현보다 **수식의 의미를 끝까지 유지하는 사고**가 핵심이다.

