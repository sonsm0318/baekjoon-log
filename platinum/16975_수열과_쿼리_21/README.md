📘 세그먼트 트리로 Lazy 없이 구간 덧셈 + 단일 조회 구현하기

    "복습 문제"가 아니라, 내 구현 역량과 논리적 사고를 확장하는 실전 훈련이었다.
    Lazy를 몰라도 되지만, '그 철학'은 내 사고 속에서 이미 구현되고 있었다.

🧠 핵심 아이디어 요약

    Lazy Propagation을 쓰지 않고도,
    1 i j k → 구간 [i, j]에 k를 더하고
    2 x → A[x]의 현재 값을 구하는 문제를 해결하고자 했다.

    내 방식은 다음과 같은 철학을 따른다:

        "즉시 반영하지 말고,
        각 노드에 필요한 정보만 누적해 두고
        진짜 필요할 때만 꺼내 쓰자."

    이건 **게으른 계산 (lazy computation)**의 사고를 구현적 차원에서 직접 설계한 것이다.

🔍 내가 택한 전략 (Lazy 없이 Lazy한 구조)

    각 노드에 sum 필드를 두고,
    구간 갱신은 단순히 해당 범위에 sum += k만 저장
    → 자식 노드에는 전파하지 않음

    조회 시 루트부터 내려가며,
    해당 노드의 sum을 누적해서 더해주고
    최종적으로 A[x]에 반영

    결국, 필요한 정보만 최소한의 방식으로 누적/전달하며
    시간 복잡도는 O(log N)을 지키면서 Lazy와 유사한 효과를 냄

🧱 사고 과정에서 겪은 오류와 교훈

    mid 계산 실수 → 재귀 무한 루프

    쿼리의 방향 조건 (find <= mid)을 반대로 써서 잘못된 자식 탐색

    sum +=이 아닌 sum =으로 덮어써 누적 정보 소실

    int 오버플로우로 결과가 이상하게 나옴 → long long 전환

    단순한 실수가 아니라, 논리의 경로가 얼마나 쉽게 무너지는지를 체감했다.
    디버깅은 내 코드가 아니라, 내 사고 방식을 테스트하는 과정이었다.

⚖ 왜 이 방식이 통했는가?

    문제 조건이 **"구간 덧셈 + 단일 조회"**만을 요구함
    → Lazy 트리의 전체적 구조 없이도 해결 가능

    오히려 Lazy 구조보다 더 직관적으로,
    내가 이해하고 설계한 방식이 더 빠르게 통과됨

    "기능적 최적화"보다 "사고 기반 설계"가 얼마나 중요한지를 직접 체험함

🧩 나의 구현은 무엇을 증명했는가?

    자료구조는 "정해진 틀"이 아닌,
    문제에 따라 재해석되고 창조될 수 있는 사고의 산물이라는 것

    Lazy Tree는 **구현을 암기하는 대상이 아니라,
    ‘언제 쓰고 언제 생략할지 판단할 줄 아는 사고 도구’**라는 것

🗂️ 정리 키워드

    세그먼트 트리, 구간 덧셈, 단일 조회,
    지연 계산, 수동 Lazy 구조, 누적값 전파,
    구현 사고력, 자료형 오버플로우, 트리 탐색 조건 설계

🔚 최종 결론

    "지금은 Lazy를 쓸 타이밍이 아니야."

    왜냐면 나는 내 방식으로 문제를 완벽히 해결했고,
    그것이 Lazy와 같은 철학을 따르고 있기 때문이다.

    Lazy는 나중에 진짜 필요할 때, 더 깊이, 더 정밀하게 배운다.
    지금은 내 구조가 답이다.
