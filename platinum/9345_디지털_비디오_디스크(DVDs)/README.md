# DVD 시뮬레이션 검증 (BOJ 13172 변형 문제)

## 문제 개요
- DVD 번호는 1부터 N까지 중복 없이 존재
- 손님은 DVD를 어떤 구간에서 가져왔다고 주장
- 이게 **진영의 행동(두 DVD swap)으로 도달 가능한 상태인지** 판단해야 함

---

## 핵심 로직

- `arr[]` : 현재 DVD 상태를 저장하는 배열
- `tree[]` : 세그트리로 각 구간의 min/max 값을 저장
- `swap(a, b)` : 진영이 두 DVD 위치를 바꾸는 동작을 시뮬레이션
- `update()` : 세그트리의 값을 실제 DVD 번호로 갱신
- `query()` : 주어진 구간의 최소값/최대값 확인

---

## 판단 기준

- 구간 `[first+1, second+1]`의 DVD가 정렬되어 있다면  
  → `min == first+1 && max == second+1`  
  → 순열 구간임이 보장되므로 "YES"

- 그렇지 않으면 "NO"

---

## 시간복잡도

- 초기 build: O(N)
- update: O(log N)
- query: O(log N)
- M개의 작업 처리 총합: O(M log N)

---

## 주요 함수 설명

### `build()`
- 세그트리 노드에 현재 구간의 min/max DVD 번호 저장

### `update()`
- 특정 위치의 DVD 번호를 변경하고, 위로 올라가며 min/max 갱신

### `query()`
- 구간 `[l, r]`에 대해 min/max를 리턴

### `swap()`
- arr 배열에서 값을 swap하고, 해당 위치를 update로 반영

---

## 실수 포인트

- 출력 형식: "YES"와 "Yes"를 구분해야 하므로 반드시 대문자로 출력!
- DVD 번호는 `1-indexed`, 배열은 `0-indexed`이므로 오프셋 처리에 주의

---

## 회고

- 처음엔 벡터를 정렬해 비교하려다 시간복잡도가 불안했음
- 이후 세그트리로 구간 min/max만 비교해도 충분하다는 걸 파악
- 전체 구조를 간소화하고, 조건문을 O(1)로 줄이면서 최적화 성공

> 🧠 **단순한 조건을 만족할 때, 세그트리는 무기처럼 쓸 수 있다!**
